<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Los Sueños de Samay - Living Dream Machine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #f5f5f0;
            color: #1a1a1a;
            overflow: hidden;
            position: relative;
        }

        .graph-paper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(100,100,200,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(100,100,200,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: 1;
            transition: opacity 2s ease;
        }

        .graph-paper.dissolving {
            animation: dissolve 5s ease forwards;
        }

        @keyframes dissolve {
            to {
                background-size: 50px 50px;
                opacity: 0.2;
            }
        }

        #memoryCanvas, #drawingCanvas, #wordCanvas, #interactionCanvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #memoryCanvas { z-index: 2; opacity: 0.3; }
        #drawingCanvas { z-index: 3; }
        #wordCanvas { z-index: 4; }
        #interactionCanvas { z-index: 5; pointer-events: all; }

        .container {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            pointer-events: none;
        }

        .container button {
            pointer-events: all;
        }

        h1 {
            font-size: clamp(2rem, 6vw, 5rem);
            font-weight: 100;
            letter-spacing: -0.05em;
            margin-bottom: 1rem;
            /* mix-blend-mode: difference; */
            color: blue;
        }
        .title-screen {
            /* Apply the same glassmorphism logic */
            background: rgba(245, 245, 240, 0.7); /* A slightly higher opacity can be good for a main menu */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 15px;
            border: 1px solid rgba(26, 26, 26, 0.1);

            /* Add padding to give the content breathing room inside the panel */
            padding: 3rem;
            
            /* Box shadow can help lift the main panel off the background */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1); 
        }
        .title-letters {
            display: inline-block;
            transition: all 0.5s ease;
        }

        .title-letters.dispersing {
            animation: disperse 3s ease forwards;
        }

        @keyframes disperse {
            to {
                transform: translate(var(--dx), var(--dy)) rotate(var(--rot));
                opacity: 0;
            }
        }

        .poem-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-top: 3rem;
        }

        .poem-button {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid #1a1a1a;
            color: #1a1a1a;
            cursor: crosshair;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
            position: relative;
            overflow: hidden;
        }

        .poem-button:hover {
            transform: scale(1.05);
        }

        .poem-button.activated {
            animation: melt 2s ease forwards;
        }

        @keyframes melt {
            to {
                letter-spacing: 10px;
                opacity: 0;
                transform: translateY(20px);
            }
        }

        .poem-display {
            display: none;
            width: 90%;
            max-width: 800px;
            pointer-events: all;
        }

        .poem-display.active {
            display: block;
        }

        /* Combine your two .poem-text rules into one */
        .poem-text {
            /* Glassmorphism */
            background: rgba(245, 245, 240, 0.65);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(26, 26, 26, 0.1);

            /* Text & Layout */
            font-size: 1.2rem;
            line-height: 2;
            position: relative;
            z-index: 20;
            padding: 2rem;
            color: #1a1a1a;
            text-shadow: 0 0 8px rgba(245, 245, 240, 0.8);
        }

        .poem-word {
            display: inline-block;
            transition: all 0.5s ease;
  
        }

        .poem-word:hover {
            color: #483d8b; /* A distinct, dark slate blue */
            text-shadow: 0 0 10px rgba(72, 61, 139, 0.6); /* Add a subtle glow */
        }

        .poem-word.dissolving {
            animation: word-dissolve 2s ease forwards;
        }

        @keyframes word-dissolve {
            to {
                transform: rotate(180deg) scale(0);
                opacity: 0;
            }
        }

        .poem-word.becoming-line {
            /* These properties ensure the word shrinks smoothly without breaking to a new line */
            overflow: hidden;
            white-space: nowrap;

            /* Apply the new animation */
            animation: shrink-and-fade 1s forwards;
        }

        @keyframes shrink-and-fade {
            0% {
                opacity: 1;
                max-width: 150px; /* An initial width larger than any single word */
            }
            30% {
                opacity: 0; /* Start fading out early */
            }
            100% {
                opacity: 0;
                max-width: 0; /* Shrink the container to zero width */
                padding: 0;   /* Remove any horizontal padding */
                margin: 0;    /* Remove any horizontal margin */
            }
        }

        /* Style for the new toggle button */
        .toggle-vis-button {
            position: absolute;
            top: 3rem;
            right: 4rem;
            background: none;
            border: none;
            padding: 0;
            opacity: 0.7;
            cursor: pointer;
            transition: opacity 0.3s ease;
            z-index: 25; /* To ensure it's on top of the poem-text */
        }

        .toggle-vis-button:hover {
            opacity: 0.8;
        }

        .eye-icon {
            width: 28px;
            height: 28px;
            stroke: #1a1a1a;
        }

        /* This class will be toggled by JS to hide the glass effect */
        .poem-text.bg-hidden {
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border-color: transparent;
            box-shadow: none;
            /* Also remove the text-shadow to test raw legibility */
            text-shadow: none;
        }
        /* The main cursor container */
        .custom-cursor {
            position: fixed;
            width: 25px;
            height: 25px;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;

            /* NEW: Use CSS Grid to perfectly center the child elements */
            display: grid;
            place-items: center;
        }

        /* The children: dot and ring */
        .cursor-dot, .cursor-ring {
            /* This makes them stack on top of each other in the same grid cell */
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            
            /* We no longer need any position, top, left, or transform properties here */
        }

        /* Specific styles for the dot */
        .cursor-dot {
            width: 4px;
            height: 4px;
            background: #1a1a1a;
            border-radius: 50%; /* Ensure it's a circle */
        }

        /* Specific styles for the ring */
        .cursor-ring {
            width: 100%; /* Ring will be 25px, same as parent */
            height: 100%;/* Ring will be 25px, same as parent */
            border: 2px solid #1a1a1a;
            border-radius: 50%; /* Ensure it's a circle */
            box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.7);
            transition: all 0.1s ease;
        }

        /* This hover state remains the same and will work correctly now */
        .custom-cursor.cursor-hover .cursor-ring {
            transform: scale(2.5);
            border-width: 1px;
            box-shadow: none;
        }

        .cursor-ring.pulsing {
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(2); }
        }
        /* Add this to your CSS file */

        .custom-cursor.cursor-hover .cursor-dot {
            opacity: 0; /* Hide the central dot */
        }


        .back-button {
            position: fixed;
            top: 2rem;
            left: 2rem;
            padding: 0.5rem 1rem;
            background: rgba(245, 245, 240, 0.9);
            border: 1px solid #1a1a1a;
            color: #1a1a1a;
            cursor: crosshair;
            z-index: 100;
            font-family: 'Courier New', monospace;
        }

        .mode-indicator {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            font-size: 0.8rem;
            opacity: 0.5;
            z-index: 100;
            font-family: 'Courier New', monospace;
            max-width: 300px;
            text-align: right;
        }

        .memory-counter {
            position: fixed;
            top: 2rem;
            right: 2rem;
            font-size: 0.8rem;
            opacity: 0.5;
            z-index: 100;
        }

        .floating-fragment {
            position: fixed;
            pointer-events: none;
            font-style: italic;
            opacity: 0;
            z-index: 15;
            animation: float-fragment 10s ease forwards;
        }

        @keyframes float-fragment {
            0% {
                opacity: 0;
                transform: translate(0, 0) rotate(0deg);
            }
            10% {
                opacity: 0.7;
            }
            90% {
                opacity: 0.7;
            }
            100% {
                opacity: 0;
                transform: translate(var(--float-x), var(--float-y)) rotate(360deg);
            }
        }

        .sound-reactive {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            padding: 0.5rem 1rem;
            background: rgba(245, 245, 240, 0.9);
            border: 1px solid #1a1a1a;
            color: #1a1a1a;
            cursor: crosshair;
            z-index: 100;
            font-family: 'Courier New', monospace;
        }

        .sound-reactive.active {
            background: #1a1a1a;
            color: #f5f5f0;
            animation: sound-pulse 1s ease infinite;
        }

        @keyframes sound-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .void-space {
            position: fixed;
            background: radial-gradient(circle, transparent 0%, rgba(245, 245, 240, 0.9) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 6;
            animation: void-grow 3s ease forwards;
        }

        @keyframes void-grow {
            from {
                width: 0;
                height: 0;
            }
            to {
                width: 200px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="graph-paper" id="graphPaper"></div>
    <canvas id="memoryCanvas"></canvas>
    <canvas id="drawingCanvas"></canvas>
    <canvas id="wordCanvas"></canvas>
    <canvas id="interactionCanvas"></canvas>
    
    <div class="custom-cursor">
        <div class="cursor-dot"></div>
        <div class="cursor-ring"></div>
    </div>
    
    <div class="container">
        <div class="title-screen" id="titleScreen">
            <h1 id="mainTitle">LOS SUEÑOS DE SAMAY</h1>
            
            <div class="poem-nav">
                <button class="poem-button" onclick="enterPoem('pyramid')">PYRAMID</button>
                <button class="poem-button" onclick="enterPoem('delirium')">DELIRIUM</button>
                <button class="poem-button" onclick="enterPoem('railroad')">RAILROAD</button>
                <button class="poem-button" onclick="enterPoem('trunk')">TRUNK</button>
                <button class="poem-button" onclick="enterPoem('void')">VOID</button> 
                <button class="poem-button" onclick="enterPoem('source')">SOURCE</button>
                <button class="poem-button" onclick="enterPoem('el_san_cosme')">EL SAN COSME</button>
            </div>
        </div>
        
        <div class="poem-display" id="poemDisplay">
            <button class="back-button" onclick="returnHome()">←</button>
            
            <button class="toggle-vis-button" id="toggleVisButton" title="Toggle background">
                <svg class="eye-icon eye-open" viewBox="0 0 24 24" fill="none" stroke-width="1.5" stroke="currentColor">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                    <circle cx="12" cy="12" r="3" />
                </svg>
                <svg class="eye-icon eye-closed" style="display: none;" viewBox="0 0 24 24" fill="none" stroke-width="1.5" stroke="currentColor">
                    <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" />
                    <line x1="1" y1="1" x2="23" y2="23" />
                </svg>
            </button>

            <div class="poem-text" id="poemText"></div>
        </div>
    </div>
    
    <div class="memory-counter">memories: <span id="memoryCount">0</span></div>
    <button class="sound-reactive" id="soundBtn" onclick="toggleSound()">speak to awaken</button>
    <div class="mode-indicator" id="modeIndicator">click words to transform them | hold & drag to draw | memories accumulate</div>

    <script>
        // Initialize all canvases
        const memCanvas = document.getElementById('memoryCanvas');
        const memCtx = memCanvas.getContext('2d');
        const drawCanvas = document.getElementById('drawingCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const wordCanvas = document.getElementById('wordCanvas');
        const wordCtx = wordCanvas.getContext('2d');
        const interCanvas = document.getElementById('interactionCanvas');
        const interCtx = interCanvas.getContext('2d');
        const toggleBtn = document.getElementById('toggleVisButton');
        const poemTextEl = document.getElementById('poemText');
        const eyeOpenIcon = toggleBtn.querySelector('.eye-open');
        const eyeClosedIcon = toggleBtn.querySelector('.eye-closed');

        toggleBtn.addEventListener('click', () => {
            poemTextEl.classList.toggle('bg-hidden');
            const isHidden = poemTextEl.classList.contains('bg-hidden');
            eyeOpenIcon.style.display = isHidden ? 'none' : 'block';
            eyeClosedIcon.style.display = isHidden ? 'block' : 'none';
        });
        let hue = 240; // Start at blue
        function resizeCanvases() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            memCanvas.width = drawCanvas.width = wordCanvas.width = interCanvas.width = w;
            memCanvas.height = drawCanvas.height = wordCanvas.height = interCanvas.height = h;
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Memory system - accumulates all drawings
        let memoryMarks = [];
        let memoryCount = 0;
        
        // Load memory from localStorage
        function loadMemory() {
            const saved = localStorage.getItem('samay_memory');
            if (saved) {
                memoryMarks = JSON.parse(saved);
                memoryCount = memoryMarks.length;
                document.getElementById('memoryCount').textContent = memoryCount;
                drawMemory();
            }
        }

        function saveMemory() {
            localStorage.setItem('samay_memory', JSON.stringify(memoryMarks.slice(-1000))); // Keep last 1000 marks
        }

        function drawMemory() {
            memCtx.clearRect(0, 0, memCanvas.width, memCanvas.height);
            memCtx.globalAlpha = 0.1; // Faint memory effect
            
            memoryMarks.forEach(mark => {
                // Use the HUE saved with each mark to set its color
                memCtx.strokeStyle = `hsl(${mark.hue}, 90%, 55%)`; 
                memCtx.lineWidth = mark.width * 0.5;
                
                memCtx.beginPath();
                memCtx.moveTo(mark.from.x, mark.from.y);
                memCtx.lineTo(mark.to.x, mark.to.y);
                memCtx.stroke();
            });
        }

        // Load memories on start
        loadMemory();

        // Custom cursor
        const cursor = document.querySelector('.custom-cursor');
        const cursorRing = document.querySelector('.cursor-ring');
        
        document.addEventListener('mousemove', (e) => {
            const cursorSize = 25; 

            // Position the container by subtracting half its size.
            // This effectively centers the container on the mouse pointer.
            cursor.style.left = (e.clientX - cursorSize / 2) + 'px';
            cursor.style.top = (e.clientY - cursorSize / 2) + 'px';
        });
        function attachCursorEvents() {
            // Find all elements that should trigger the cursor change
            const interactiveElements = document.querySelectorAll('button');
            const cursor = document.querySelector('.custom-cursor');

            interactiveElements.forEach(el => {
                el.addEventListener('mouseenter', () => {
                    cursor.classList.add('cursor-hover');
                });
                el.addEventListener('mouseleave', () => {
                    cursor.classList.remove('cursor-hover');
                });
            });
        }
        // Entity system for autonomous drawing
        let entities = [];
        
        class DrawingEntity {
            constructor(x, y, type = 'wanderer') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = (Math.random() - 0.5) * 3;
                this.life = 1.0;
                this.decay = Math.random() * 0.01 + 0.005;
                this.thickness = Math.random() * 3 + 1;
                this.angle = Math.random() * Math.PI * 2;
                this.points = [{x: this.x, y: this.y}];
                this.maxPoints = 50;
                this.personality = Math.random();
                this.color = '#1a1a1a';
                this.seeking = null;
                this.avoiding = [];
            }

            update() {
                // Different behaviors based on type
                switch(this.type) {
                    case 'wanderer':
                        this.wander();
                        break;
                    case 'seeker':
                        this.seek();
                        break;
                    case 'geometric':
                        this.geometric();
                        break;
                    case 'word-born':
                        this.wordBehavior();
                        break;
                    case 'void':
                        this.voidBehavior();
                        break;
                    case 'seagull':
                        this.seagull();
                        break;
                    case 'cloud':
                        this.cloud();
                        break;

                }

                // Entity interaction
                entities.forEach(other => {
                    if (other === this) return;
                    const dist = Math.hypot(this.x - other.x, this.y - other.y);
                    
                    if (dist < 50) {
                        if (this.personality > 0.7) {
                            // Attracted
                            this.vx += (other.x - this.x) * 0.01;
                            this.vy += (other.y - this.y) * 0.01;
                        } else if (this.personality < 0.3) {
                            // Repelled
                            this.vx -= (other.x - this.x) * 0.02;
                            this.vy -= (other.y - this.y) * 0.02;
                        }
                    }
                });

                // Apply physics
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.x += this.vx;
                this.y += this.vy;

                // Boundary behavior
                if (this.x < 0 || this.x > drawCanvas.width) {
                    this.vx *= -1;
                    this.x = Math.max(0, Math.min(drawCanvas.width, this.x));
                }
                if (this.y < 0 || this.y > drawCanvas.height) {
                    this.vy *= -1;
                    this.y = Math.max(0, Math.min(drawCanvas.height, this.y));
                }

                // Update trail
                this.points.push({x: this.x, y: this.y});
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }

                this.life -= this.decay;
            }

            wander() {
                this.angle += (Math.random() - 0.5) * 0.3;
                this.vx += Math.cos(this.angle) * 0.3;
                this.vy += Math.sin(this.angle) * 0.3;
            }

            seek() {
                if (this.seeking) {
                    const dx = this.seeking.x - this.x;
                    const dy = this.seeking.y - this.y;
                    this.vx += dx * 0.01;
                    this.vy += dy * 0.01;
                } else {
                    this.wander();
                }
            }

            seagull() {
                // Moves across the screen with a gentle sine wave for soaring
                this.x += this.vx;
                this.y += Math.sin(this.x * 0.02) * 1.5; // Adjust multipliers for different flight patterns
                this.life -= 0.005; // Seagulls last a long time
            }
            cloud() {
                if (this.life < 1) this.life += 0.01; // Fade in slowly
                this.x += this.vx;
            }
            geometric() {
                if (Math.random() > 0.95) {
                    this.vx = (Math.random() > 0.5 ? 1 : -1) * 5;
                    this.vy = (Math.random() > 0.5 ? 1 : -1) * 5;
                }
            }

            wordBehavior() {
                // Spiraling, poetic movement
                this.angle += 0.1;
                const radius = 2 + Math.sin(Date.now() * 0.001) * 2;
                this.vx += Math.cos(this.angle) * radius * 0.1;
                this.vy += Math.sin(this.angle) * radius * 0.1;
            }

            voidBehavior() {
                // Consume nearby points
                this.thickness = Math.sin(Date.now() * 0.01) * 5 + 5;
                entities.forEach(other => {
                    if (other === this) return;
                    const dist = Math.hypot(this.x - other.x, this.y - other.y);
                    if (dist < 100) {
                        other.life -= 0.02;
                    }
                });
            }

            draw() {
                drawCtx.save();
                drawCtx.globalAlpha = this.life * 0.7;
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                drawCtx.lineWidth = this.thickness * this.life;

                // --- START: New Gradient Drawing Logic for Trails ---

                // 1. Instead of drawing the whole path at once, loop through each segment.
                for (let i = 1; i < this.points.length; i++) {
                    const prev = this.points[i - 1];
                    const current = this.points[i];

                    // 2. Create a unique gradient for this specific segment.
                    const gradient = drawCtx.createLinearGradient(prev.x, prev.y, current.x, current.y);
                    gradient.addColorStop(0, 'hsl(215, 100%, 70%)'); // Bright, vibrant blue
                    gradient.addColorStop(0.5, 'hsl(240, 100%, 50%)'); // Deep, royal blue
                    gradient.addColorStop(1, 'hsl(265, 95%, 55%)');   // Cool, rich indigo/purple

                    // 3. Draw just this one segment with its gradient.
                    drawCtx.strokeStyle = gradient;
                    drawCtx.beginPath();
                    drawCtx.moveTo(prev.x, prev.y);
                    drawCtx.lineTo(current.x, current.y);
                    drawCtx.stroke();
                }

                // --- END: New Gradient Drawing Logic for Trails ---

                // The type-specific drawing logic remains the same, adding extra details.
                if (this.type === 'geometric' && Math.random() > 0.9) {
                    drawCtx.strokeRect(this.x - 5, this.y - 5, 10, 10);
                } else if (this.type === 'word-born') {
                    drawCtx.beginPath();
                    drawCtx.arc(this.x, this.y, this.thickness, 0, Math.PI * 2);
                    drawCtx.stroke();
                } else if (this.type === 'void') {
                    drawCtx.fillStyle = 'rgba(245, 245, 240, 0.5)';
                    drawCtx.beginPath();
                    drawCtx.arc(this.x, this.y, this.thickness * 3, 0, Math.PI * 2);
                    drawCtx.fill();
                }
                if (this.type === 'cloud') {
                    // Draw several overlapping circles to create a cloud shape
                    drawCtx.fillStyle = `rgba(40, 40, 60, ${this.life * 0.1})`; // Dark blue-gray
                    for (let i = 0; i < 5; i++) {
                        drawCtx.beginPath();
                        drawCtx.arc(this.x + (i*15 - 30), this.y + (Math.random()*10 - 5), 20, 0, Math.PI * 2);
                        drawCtx.fill();
                    }
                }
                drawCtx.restore();
            }
        }

        // Word transformation system
        class WordParticle {
            constructor(word, x, y) {
                this.word = word;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 1.0;
                this.rotation = 0;
                this.scale = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2; // gravity
                this.rotation += 0.1;
                this.life -= 0.02;
                this.scale = this.life;
            }

            draw() {
                wordCtx.save();
                wordCtx.globalAlpha = this.life;
                wordCtx.translate(this.x, this.y);
                wordCtx.rotate(this.rotation);
                wordCtx.scale(this.scale, this.scale);
                wordCtx.font = '16px Courier New';
                wordCtx.fillStyle = '#1a1a1a';
                wordCtx.fillText(this.word, 0, 0);
                wordCtx.restore();
            }
        }

        let wordParticles = [];

        // Interactive drawing
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingPath = [];

        interCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            lastX = e.offsetX;
            lastY = e.offsetY;
            drawingPath = [{x: lastX, y: lastY}];
            
            // Spawn entities on click
            for (let i = 0; i < 2; i++) {
                entities.push(new DrawingEntity(e.offsetX, e.offsetY, 
                    Math.random() > 0.5 ? 'wanderer' : 'geometric'));
            }
        });

        interCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const currentX = e.offsetX;
            const currentY = e.offsetY;
            
            // --- START: New Gradient Drawing Logic ---

            // 1. Create a gradient that spans from the last point to the current one.
            const gradient = drawCtx.createLinearGradient(lastX, lastY, currentX, currentY);

            // 2. Define the "sunset" colors for the gradient.
            gradient.addColorStop(0, 'hsl(271, 100%, 50%)');   
            gradient.addColorStop(0.5, 'hsl(266, 98%, 48%)'); 
            gradient.addColorStop(1, 'hsl(273, 100%, 50%)');  

            // 3. Apply the gradient and draw the line segment.
            drawCtx.strokeStyle = gradient;
            drawCtx.lineWidth = 2;
            drawCtx.lineCap = 'round';
            
            drawCtx.beginPath();
            drawCtx.moveTo(lastX, lastY);
            drawCtx.lineTo(currentX, currentY);
            drawCtx.stroke();
            
            // --- END: New Gradient Drawing Logic ---
            
            // Save to memory, now including the current hue for recoloring later.
            const mark = {
                from: {x: lastX, y: lastY},
                to: {x: currentX, y: currentY},
                width: 2,
                hue: hue // NEW: Save the hue at this moment in time.
            };
            memoryMarks.push(mark);
            memoryCount++;
            document.getElementById('memoryCount').textContent = memoryCount;
            
            // This part remains the same.
            if (Math.random() > 0.95) {
                entities.push(new DrawingEntity(currentX, currentY, 'word-born'));
            }
            
            drawingPath.push({x: currentX, y: currentY});
            lastX = currentX;
            lastY = currentY;
        });

        interCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
            saveMemory();
            drawMemory();
            
            // Create connections between path points
            if (drawingPath.length > 10) {
                drawCtx.save();
                drawCtx.globalAlpha = 0.1;
                drawCtx.strokeStyle = '#1a1a1a';
                drawCtx.lineWidth = 0.5;
                
                for (let i = 0; i < 3; i++) {
                    const p1 = drawingPath[Math.floor(Math.random() * drawingPath.length)];
                    const p2 = drawingPath[Math.floor(Math.random() * drawingPath.length)];
                    drawCtx.beginPath();
                    drawCtx.moveTo(p1.x, p1.y);
                    drawCtx.lineTo(p2.x, p2.y);
                    drawCtx.stroke();
                }
                drawCtx.restore();
            }
        });

        // Poem data with trigger words
        const poems = {
            pyramid: {
                text: `The rain must be the tears of God,
        The years of laying bricks are done. 
        The pyramid has not collapsed.
        Even when the seas give rise,
        Hear the seagulls overhead, 
        gliding in the open air, 
        salty mist and swirling breeze, 
        like a ghost above the waves.  
        The waves have never known retreat,
        washing over mankind’s sins, 
        wash to shore a heart of jade,  
        Rendered smooth by pulling tides, 
        cast it if you dare to love,
        and watch it sink into the depths.`,
                triggers: {
                    'heart': () => createHeartPattern(),
                    'sink': () => createVoid(),
                    'depths': () => createVoid()
                }
            },
            
            trunk: {
                text: `The tree trunk 
        flat and wide,
        with roots by the creek. 
        The spirit inside
        white clouds
        Thanks to God
        and the hollow 
        strums of a guitar`,
                triggers: {
                    'roots': () => createRootSystem()
                }
            },
            
            railroad: {
                text: `The trains never stopped. Whistling across the plateau,
        thundering the desert floor until kicking up an angry cloud of dust. 
        Found chained to the tracks, eyes closed and half blind from the Sun.
        Dazed and severe, monastic silence of a nun, I try to sum 
        the seconds spent with angels and those with devils, 
        if the self is a reflection of the company surrounding, 
        I will be judged between the wolf and a shepherd. 
        Every debt is paid when the final trumpet’s sounding,
        and the chains are not budging,
        I look to my side and see a white pigeon has landed, 
        O Sweet Bird, deliver my cries to your Mother!`,
                triggers: {
                    'trains': () => createRailroadTracks(),
                    'chained': () => constrainEntities(),
                    'pigeon': () => createPigeon()
                }
            },
            
            void: {
                text: `The void is my homeland 
        All a drop of dew 
        But still 
        Sweet mother 
        I will always love you`,
                triggers: {
                    'void': () => createVoid()
                }
            },
            
            source: {
                text: `Contend with the darkness 
        Inside your heart 
        That spills out like ink from my pen 
        To leave a smudge on your face 
        Stained love 
        An angel of death 
        I’ll float around your head 
        False imprisonment 
        A double awakening 
        One path that is Heaven sent 
        And another of darker ends 
        Your skin is glowing 
        Mine is burning
        Your wings are melting 
        Too close to the source`,
                triggers: {
                    'burning': () => createFire(),
                    'glowing': () => createFire()
                }
            },
            
            delirium: {
                text: `Please take a form and be given contour by the works of the great sculptor
        From ash to ash and dust to dust, the stardust that becomes you
        Was here long ago, and I was you and you were me and we were free 
        Before the lock was fixed beyond our reach
        And the key was shed from careless hands,
        Swallowed by the grains of sand 
        That were once blades of grass against your back
        Dig like the earth contains salvation
        Fill the hole in your heart with mud
        Perceptions of heat and dark
        Caving walls and barren roots, sulfuric sweetness, 
        Pressure that strolls like a midnight lark 
        And catches all attention, 
        Like a singular cloud centered on vanished skies,
        I close my eyes and think of air
        The type that dews in the morning
        And vapors like a plume of smoke in the snow
        Fill my lungs with delirious strands of thought
        And crystallize the space within my head
        Until it shines translucent like a diamond.`,
                triggers: {
                    'branches': () => createBranching(),
                    'dissolves': () => dissolveScreen(),
                    'forgetting': () => fadeMemory()
                }
            },

        el_san_cosme: {
            text: `En la cima del cerro san Cosme 
        La costa abierta, gaviotas vuelan,
        Balsas y veleros
        Flotando en el muelle 
        Más allá del cerro San Cosme
        La Creación se abre 
        Como una flor 
        Libre en el aire
        Que fluye salado
        Amigo, respira  
        Y mantenga la mirada 
        Hacia el Oeste 
        Al gran horizonte 
        Nubes grises que llevan 
        Tormentas profundas 
        Sobre azules oscuros 
        Y llegan a la costa 
        como una brisa no más`,
            triggers: {
                'gaviotas': () => spawnSeagulls(),
                'flor': () => createBloomingFlower(),
                'Nubes': () => createStormClouds(),
                'Tormentas': () => createStormClouds()
            }
        },
        };

        let currentPoem = null;

        function enterPoem(poemKey) {
            currentPoem = poems[poemKey];
            
            // Animate title dissolution
            const title = document.getElementById('mainTitle');
            const letters = title.textContent.split('').map((letter, i) => {
                const span = document.createElement('span');
                span.textContent = letter;
                span.className = 'title-letters';
                span.style.setProperty('--dx', `${(Math.random() - 0.5) * 200}px`);
                span.style.setProperty('--dy', `${(Math.random() - 0.5) * 200}px`);
                span.style.setProperty('--rot', `${(Math.random() - 0.5) * 720}deg`);
                return span;
            });
            title.innerHTML = '';
            letters.forEach(span => title.appendChild(span));
            
            setTimeout(() => {
                letters.forEach(span => span.classList.add('dispersing'));
            }, 100);
            
            // Show poem with interactive words
            setTimeout(() => {
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('poemDisplay').classList.add('active');
                
                const poemText = document.getElementById('poemText');
                const words = currentPoem.text.split(/(\s+)/);
                poemText.innerHTML = '';
                
                words.forEach(word => {
                    if (word.trim()) {
                        const span = document.createElement('span');
                        span.className = 'poem-word';
                        span.textContent = word;
                        span.onclick = () => transformWord(span, word);
                        poemText.appendChild(span);
                        
                        // Check for trigger words
                        const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
                        if (currentPoem.triggers[cleanWord]) {
                            span.style.textDecoration = 'underline';
                            span.style.textDecorationStyle = 'wavy';
                        }
                    } else {
                        poemText.appendChild(document.createTextNode(word));
                    }
                });
               
            }, 2000);

            
            attachCursorEvents(); 
            // Dissolve graph paper
            document.getElementById('graphPaper').classList.add('dissolving');
        }

        function transformWord(element, word) {
            const rect = element.getBoundingClientRect();
            const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
            
            // Execute trigger if exists
            if (currentPoem && currentPoem.triggers[cleanWord]) {
                currentPoem.triggers[cleanWord]();
            }
            
            // Visual transformation
            element.classList.add('becoming-line');
            
            // Create word particle
            wordParticles.push(new WordParticle(word, rect.left + rect.width/2, rect.top + rect.height/2));
            
            // Spawn drawing entity from word
            setTimeout(() => {
                for (let i = 0; i < word.length; i++) {
                    entities.push(new DrawingEntity(
                        rect.left + rect.width/2 + (Math.random() - 0.5) * 50,
                        rect.top + rect.height/2 + (Math.random() - 0.5) * 50,
                        'word-born'
                    ));
                }
            }, 500);
            
            // Create floating fragment
            const fragment = document.createElement('div');
            fragment.className = 'floating-fragment';
            fragment.textContent = word;
            fragment.style.left = rect.left + 'px';
            fragment.style.top = rect.top + 'px';
            fragment.style.setProperty('--float-x', `${(Math.random() - 0.5) * 300}px`);
            fragment.style.setProperty('--float-y', `${(Math.random() - 0.5) * 300}px`);
            document.body.appendChild(fragment);
            
            setTimeout(() => fragment.remove(), 10000);
        }

        function returnHome() {
            document.getElementById('titleScreen').style.display = 'block';
            document.getElementById('poemDisplay').classList.remove('active');
            document.getElementById('graphPaper').classList.remove('dissolving');
            
            // --- NEW: Reset the visibility toggle state ---
            poemTextEl.classList.remove('bg-hidden'); // Ensure background is visible by default
            eyeOpenIcon.style.display = 'block';      // Show the open eye icon
            eyeClosedIcon.style.display = 'none';     // Hide the closed eye icon
            
            // Reset title
            document.getElementById('mainTitle').innerHTML = 'LOS SUEÑOS DE SAMAY';
        }

        // Trigger functions
        function createHeartPattern() {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const x = cx + 16 * Math.pow(Math.sin(angle), 3) * 10;
                const y = cy - (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * 10;
                entities.push(new DrawingEntity(x, y, 'seeker'));
            }
        }

        function createVoid() {
            const Void = document.createElement('div');
            Void.className = 'void-space';
            Void.style.left = Math.random() * window.innerWidth + 'px';
            Void.style.top = Math.random() * window.innerHeight + 'px';
            document.body.appendChild(Void);
            
            entities.push(new DrawingEntity(
                parseFloat(Void.style.left),
                parseFloat(Void.style.top),
                'void'
            ));
            
            setTimeout(() => Void.remove(), 3000);
        }

        function liftAllEntities() {
            entities.forEach(e => {
                e.vy -= 5;
                e.decay *= 0.5;
            });
        }
        // Add this with your other trigger functions
        function spawnSeagulls() {
            const startY = window.innerHeight * 0.1;
            for (let i = 0; i < 3; i++) {
                // Spawn 3 gulls near the top, spaced out
                const startX = (window.innerWidth / 4) * (i + 1);
                const gull = new DrawingEntity(startX, startY, 'seagull');
                entities.push(gull);
            }
        }
        function createRootSystem() {
            const startX = Math.random() * window.innerWidth;
            const startY = 0;
            
            function branch(x, y, angle, depth) {
                if (depth <= 0) return;
                
                const length = 50 * depth / 5;
                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;
                
                const root = new DrawingEntity(x, y, 'geometric');
                root.seeking = {x: endX, y: endY};
                entities.push(root);
                
                setTimeout(() => {
                    branch(endX, endY, angle - 0.5, depth - 1);
                    branch(endX, endY, angle + 0.5, depth - 1);
                }, 200);
            }
            
            branch(startX, startY, Math.PI / 2, 5);
        }

        function createTangles() {
            entities.forEach((e1, i) => {
                entities.slice(i + 1, i + 3).forEach(e2 => {
                    drawCtx.save();
                    drawCtx.globalAlpha = 0.1;
                    drawCtx.strokeStyle = '#1a1a1a';
                    drawCtx.lineWidth = 0.5;
                    drawCtx.beginPath();
                    drawCtx.moveTo(e1.x, e1.y);
                    drawCtx.quadraticCurveTo(
                        (e1.x + e2.x) / 2 + Math.random() * 100 - 50,
                        (e1.y + e2.y) / 2 + Math.random() * 100 - 50,
                        e2.x, e2.y
                    );
                    drawCtx.stroke();
                    drawCtx.restore();
                });
            });
        }

        function createRailroadTracks() {
            const y = window.innerHeight / 2;
            for (let x = 0; x < window.innerWidth; x += 50) {
                drawCtx.strokeStyle = '#1a1a1a';
                drawCtx.lineWidth = 3;
                drawCtx.beginPath();
                drawCtx.moveTo(x, y - 20);
                drawCtx.lineTo(x, y + 20);
                drawCtx.stroke();
            }
            
            drawCtx.beginPath();
            drawCtx.moveTo(0, y - 20);
            drawCtx.lineTo(window.innerWidth, y - 20);
            drawCtx.moveTo(0, y + 20);
            drawCtx.lineTo(window.innerWidth, y + 20);
            drawCtx.stroke();
        }

        function constrainEntities() {
            const y = window.innerHeight / 2;
            entities.forEach(e => {
                if (Math.abs(e.y - y) > 100) {
                    e.vy += (y - e.y) * 0.01;
                }
            });
        }

        function createPigeon() {
            const pigeon = new DrawingEntity(
                window.innerWidth / 2,
                window.innerHeight / 2 - 100,
                'seeker'
            );
            pigeon.color = '#ffffff';
            pigeon.thickness = 5;
            entities.push(pigeon);
        }

        function fillVoids() {
            entities.filter(e => e.type === 'void').forEach(Void => {
                for (let i = 0; i < 10; i++) {
                    const filler = new DrawingEntity(
                        Void.x + (Math.random() - 0.5) * 100,
                        Void.y + (Math.random() - 0.5) * 100,
                        'wanderer'
                    );
                    filler.seeking = {x: Void.x, y: Void.y};
                    entities.push(filler);
                }
            });
        }

        function createFire() {
            for (let i = 0; i < 20; i++) {
                const flame = new DrawingEntity(
                    Math.random() * window.innerWidth,
                    window.innerHeight,
                    'wanderer'
                );
                flame.vy = -Math.random() * 5 - 2;
                flame.color = `hsl(${Math.random() * 60}, 100%, 50%)`;
                entities.push(flame);
            }
        }

        function createBranching() {
            entities.forEach(e => {
                if (Math.random() > 0.7) {
                    const branch = new DrawingEntity(e.x, e.y, e.type);
                    branch.vx = e.vx + (Math.random() - 0.5) * 2;
                    branch.vy = e.vy + (Math.random() - 0.5) * 2;
                    entities.push(branch);
                }
            });
        }

        // Add this with your other trigger functions
        function createBloomingFlower() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const petals = 12;
            let radius = 10;
            let angle = 0;

            const bloomInterval = setInterval(() => {
                radius += 5; // The flower grows
                angle += 0.1; // It rotates slightly

                for (let i = 0; i < petals; i++) {
                    const petalAngle = (Math.PI * 2 / petals) * i + angle;
                    const x1 = centerX + Math.cos(petalAngle) * radius;
                    const y1 = centerY + Math.sin(petalAngle) * radius;
                    const x2 = centerX + Math.cos(petalAngle) * (radius + 50);
                    const y2 = centerY + Math.sin(petalAngle) * (radius + 50);

                    // Use the live drawing context to make a mark
                    const gradient = drawCtx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, `hsl(215, 100%, 70%)`);
                    gradient.addColorStop(1, `hsl(265, 95%, 55%)`);
                    
                    drawCtx.strokeStyle = gradient;
                    drawCtx.lineWidth = 2;
                    drawCtx.globalAlpha = 1 - (radius / 500); // Fades as it expands
                    drawCtx.beginPath();
                    drawCtx.moveTo(x1, y1);
                    drawCtx.lineTo(x2, y2);
                    drawCtx.stroke();
                }

                if (radius > 500) {
                    clearInterval(bloomInterval);
                }
            }, 20);
        }
        function createStormClouds() {
            for (let i = 0; i < 5; i++) {
                const cloud = new DrawingEntity(Math.random() * window.innerWidth, 50, 'cloud');
                cloud.vx = (Math.random() - 0.5) * 0.5; // Very slow
                cloud.vy = 0;
                cloud.life = 0; // Start invisible
                entities.push(cloud);
            }
        }
        function dissolveScreen() {
            drawCtx.save();
            drawCtx.globalAlpha = 0.02;
            drawCtx.fillStyle = '#f5f5f0';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawCtx.restore();
        }

        function fadeMemory() {
            memCanvas.style.opacity = '0.1';
            setTimeout(() => {
                memCanvas.style.opacity = '0.3';
            }, 3000);
        }

        // Sound reactive system
        let audioContext = null;
        let microphone = null;
        let analyser = null;
        let soundActive = false;

        async function toggleSound() {
            const btn = document.getElementById('soundBtn');
            
            if (!soundActive) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphone = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    microphone.connect(analyser);
                    
                    soundActive = true;
                    btn.classList.add('active');
                    btn.textContent = 'listening...';
                    
                    analyzeSoud();
                } catch (err) {
                    console.error('Microphone access denied:', err);
                    btn.textContent = 'mic access denied';
                }
            } else {
                soundActive = false;
                btn.classList.remove('active');
                btn.textContent = 'speak to awaken';
                if (audioContext) {
                    audioContext.close();
                }
            }
        }

        function analyzeSoud() {
            if (!soundActive) return;
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            
            // React to sound
            if (average > 30) {
                // Spawn entities based on volume
                const intensity = Math.min(average / 100, 1);
                
                if (Math.random() < intensity) {
                    for (let i = 0; i < intensity * 3; i++) {
                        entities.push(new DrawingEntity(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            average > 50 ? 'geometric' : 'word-born'
                        ));
                    }
                }
                
                // Make cursor pulse
                document.querySelector('.cursor-ring').classList.add('pulsing');
                setTimeout(() => {
                    document.querySelector('.cursor-ring').classList.remove('pulsing');
                }, 1000);
            }
            
            requestAnimationFrame(analyzeSoud);
        }

        // Main animation loop
        function animate() {
            // Clear word canvas
            hue = (hue + 0.1) % 360;
            wordCtx.clearRect(0, 0, wordCanvas.width, wordCanvas.height);
            
            // Update and draw entities
            entities = entities.filter(e => e.life > 0);
            entities.forEach(e => {
                e.update();
                e.draw();
            });
            
            // Update and draw word particles
            wordParticles = wordParticles.filter(p => p.life > 0);
            wordParticles.forEach(p => {
                p.update();
                p.draw();
            });
            
            // Occasionally spawn random entities
            if (Math.random() > 0.99 && entities.length < 50) {
                entities.push(new DrawingEntity(
                    Math.random() * window.innerWidth,
                    Math.random() * window.innerHeight,
                    ['wanderer', 'geometric', 'seeker'][Math.floor(Math.random() * 3)]
                ));
            }
            
            // Create connections between nearby entities
            if (Math.random() > 0.98) {
                drawCtx.save();
                drawCtx.globalAlpha = 0.05;
                drawCtx.strokeStyle = '#1a1a1a';
                drawCtx.lineWidth = 0.5;
                
                entities.forEach((e1, i) => {
                    entities.slice(i + 1).forEach(e2 => {
                        const dist = Math.hypot(e1.x - e2.x, e1.y - e2.y);
                        if (dist < 100) {
                            drawCtx.beginPath();
                            drawCtx.moveTo(e1.x, e1.y);
                            drawCtx.lineTo(e2.x, e2.y);
                            drawCtx.stroke();
                        }
                    });
                });
                drawCtx.restore();
            }
            
            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
        attachCursorEvents();
        // Initial entities
        for (let i = 0; i < 3; i++) {
            entities.push(new DrawingEntity(
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight
            ));
        }

    </script>
</body>
</html>
                